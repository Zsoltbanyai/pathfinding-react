{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/zsoltbanyai/Documents/Codecool/Advanced/PetProjects/pathfinding-zsoltbanyai/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";// Breadth-first search (BFS)\n// The BFS algorithm guarantees that the first path it finds to the end node is the shortest path\n// because of the way it explores the grid. The algorithm starts by exploring all the neighboring nodes\n// of the start node, then it explores all the neighboring nodes of the neighbor nodes, and so on.\n// It does this in a breadth-first manner, which means that it explores all the nodes at a certain depth\n// in the grid before moving on to the next depth.\n//\n// So, when the algorithm finds the end node, it has already explored all the neighboring nodes of the start node\n// and all the neighboring nodes of the neighboring nodes. Therefore, we know that the path that the algorithm finds\n// is the shortest path because it is guaranteed that the algorithm has not yet explored any shorter paths.\n//\n// Also, the algorithm uses a queue to keep track of the nodes that it needs to visit next.\n// The nodes are added to the queue in the order that they are discovered, so the first path\n// that the algorithm finds is guaranteed to be the shortest because the algorithm explores\n// the nodes in the order of their distance from the start node.\nexport function BFS(startNode,endNode,wallNodes,numOfCols,numOfRows){if(startNode===endNode)return[[startNode],[startNode]];var queue=[startNode];var visitedNodes=[];var parentNodes=new Map();while(queue.length>0){var currentNode=queue.shift();if(visitedNodes.includes(currentNode))continue;visitedNodes.push(currentNode);if(currentNode===endNode){return[retracePath(startNode,endNode,parentNodes),visitedNodes];}var _iterator=_createForOfIteratorHelper(getUnvisitedNeighbors(currentNode,endNode,visitedNodes,wallNodes,numOfCols,numOfRows)),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;queue.push(neighbor);parentNodes.set(neighbor,currentNode);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return[[],visitedNodes];}// When parentNodes is set, you take a node and add every unvisited neighbor as key, with the node as value.\n// So in retracePath, in the first iteration when you do 'parentNodes.get(currentNode)',\n// think of the endNode as the neighbor of the previous step, and so on.\nfunction retracePath(startNode,endNode,parentNodes){var path=[endNode];var currentNode=endNode;while(currentNode!==startNode){currentNode=parentNodes.get(currentNode);path.unshift(currentNode);}return path;}function getNeighbors(node,numOfCols,numOfRows){var neighbors=[];var NORTH=node-numOfCols;var SOUTH=node+numOfCols;var EAST=node+1;var WEST=node-1;var MAX=numOfCols*numOfRows;var rowNum=Math.floor(node/numOfCols);// Check north\nif(NORTH>=0){neighbors.push(NORTH);}// Check east\nif(EAST-rowNum*numOfCols!==numOfCols){neighbors.push(EAST);}// Check south\nif(SOUTH<MAX){neighbors.push(SOUTH);}// Check west\nif(node-rowNum*numOfCols!==0){neighbors.push(WEST);}return neighbors;}function getUnvisitedNeighbors(node,endNode,visitedNodes,wallNodes,numOfCols,numOfRows){var neighbors=getNeighbors(node,numOfCols,numOfRows);return neighbors.filter(function(neighbor){return!visitedNodes.includes(neighbor)&&(!wallNodes.includes(neighbor)||neighbor===endNode);});}","map":{"version":3,"names":["BFS","startNode","endNode","wallNodes","numOfCols","numOfRows","queue","visitedNodes","parentNodes","Map","length","currentNode","shift","includes","push","retracePath","getUnvisitedNeighbors","neighbor","set","path","get","unshift","getNeighbors","node","neighbors","NORTH","SOUTH","EAST","WEST","MAX","rowNum","Math","floor","filter"],"sources":["/home/zsoltbanyai/Documents/Codecool/Advanced/PetProjects/pathfinding-zsoltbanyai/src/pathfinding/algorithm/Bfs.jsx"],"sourcesContent":["// Breadth-first search (BFS)\n\n// The BFS algorithm guarantees that the first path it finds to the end node is the shortest path\n// because of the way it explores the grid. The algorithm starts by exploring all the neighboring nodes\n// of the start node, then it explores all the neighboring nodes of the neighbor nodes, and so on.\n// It does this in a breadth-first manner, which means that it explores all the nodes at a certain depth\n// in the grid before moving on to the next depth.\n//\n// So, when the algorithm finds the end node, it has already explored all the neighboring nodes of the start node\n// and all the neighboring nodes of the neighboring nodes. Therefore, we know that the path that the algorithm finds\n// is the shortest path because it is guaranteed that the algorithm has not yet explored any shorter paths.\n//\n// Also, the algorithm uses a queue to keep track of the nodes that it needs to visit next.\n// The nodes are added to the queue in the order that they are discovered, so the first path\n// that the algorithm finds is guaranteed to be the shortest because the algorithm explores\n// the nodes in the order of their distance from the start node.\n\nexport function BFS(startNode, endNode, wallNodes, numOfCols, numOfRows) {\n    if (startNode === endNode) return [[startNode], [startNode]];\n\n    let queue = [startNode];\n    let visitedNodes = [];\n    let parentNodes = new Map();\n\n    while (queue.length > 0) {\n        const currentNode = queue.shift();\n        if (visitedNodes.includes(currentNode)) continue;\n        visitedNodes.push(currentNode);\n\n        if (currentNode === endNode) {\n            return [retracePath(startNode, endNode, parentNodes), visitedNodes];\n        }\n\n        for (let neighbor of getUnvisitedNeighbors(currentNode, endNode,\n                                                   visitedNodes, wallNodes,\n                                                   numOfCols, numOfRows)) {\n            queue.push(neighbor);\n            parentNodes.set(neighbor, currentNode);\n        }\n    }\n\n    return [[], visitedNodes];\n}\n\n// When parentNodes is set, you take a node and add every unvisited neighbor as key, with the node as value.\n// So in retracePath, in the first iteration when you do 'parentNodes.get(currentNode)',\n// think of the endNode as the neighbor of the previous step, and so on.\nfunction retracePath(startNode, endNode, parentNodes) {\n    let path = [endNode];\n    let currentNode = endNode;\n\n    while (currentNode !== startNode) {\n        currentNode = parentNodes.get(currentNode);\n        path.unshift(currentNode);\n    }\n\n    return path;\n}\n\nfunction getNeighbors(node, numOfCols, numOfRows) {\n    const neighbors = [];\n\n    const NORTH = node - numOfCols;\n    const SOUTH = node + numOfCols;\n    const EAST = node + 1;\n    const WEST = node - 1;\n    const MAX = numOfCols * numOfRows;\n    const rowNum = Math.floor(node/numOfCols);\n\n    // Check north\n    if (NORTH >= 0) {\n        neighbors.push(NORTH);\n    }\n    // Check east\n    if (EAST - (rowNum * numOfCols) !== numOfCols) {\n        neighbors.push(EAST);\n    }\n    // Check south\n    if (SOUTH < MAX) {\n        neighbors.push(SOUTH);\n    }\n    // Check west\n    if (node - (rowNum * numOfCols) !== 0) {\n        neighbors.push(WEST);\n    }\n    return neighbors;\n}\n\nfunction getUnvisitedNeighbors(node, endNode, visitedNodes, wallNodes, numOfCols, numOfRows) {\n    const neighbors = getNeighbors(node, numOfCols, numOfRows);\n    return neighbors.filter(neighbor => !visitedNodes.includes(neighbor)\n                                    && (!wallNodes.includes(neighbor) || neighbor === endNode));\n}\n"],"mappings":"+LAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAO,SAASA,IAAG,CAACC,SAAS,CAAEC,OAAO,CAAEC,SAAS,CAAEC,SAAS,CAAEC,SAAS,CAAE,CACrE,GAAIJ,SAAS,GAAKC,OAAO,CAAE,MAAO,CAAC,CAACD,SAAS,CAAC,CAAE,CAACA,SAAS,CAAC,CAAC,CAE5D,GAAIK,MAAK,CAAG,CAACL,SAAS,CAAC,CACvB,GAAIM,aAAY,CAAG,EAAE,CACrB,GAAIC,YAAW,CAAG,GAAIC,IAAG,EAAE,CAE3B,MAAOH,KAAK,CAACI,MAAM,CAAG,CAAC,CAAE,CACrB,GAAMC,YAAW,CAAGL,KAAK,CAACM,KAAK,EAAE,CACjC,GAAIL,YAAY,CAACM,QAAQ,CAACF,WAAW,CAAC,CAAE,SACxCJ,YAAY,CAACO,IAAI,CAACH,WAAW,CAAC,CAE9B,GAAIA,WAAW,GAAKT,OAAO,CAAE,CACzB,MAAO,CAACa,WAAW,CAACd,SAAS,CAAEC,OAAO,CAAEM,WAAW,CAAC,CAAED,YAAY,CAAC,CACvE,CAAC,yCAEoBS,qBAAqB,CAACL,WAAW,CAAET,OAAO,CACpBK,YAAY,CAAEJ,SAAS,CACvBC,SAAS,CAAEC,SAAS,CAAC,YAFhE,+CAEkE,IAFzDY,SAAQ,aAGbX,KAAK,CAACQ,IAAI,CAACG,QAAQ,CAAC,CACpBT,WAAW,CAACU,GAAG,CAACD,QAAQ,CAAEN,WAAW,CAAC,CAC1C,CAAC,qDACL,CAEA,MAAO,CAAC,EAAE,CAAEJ,YAAY,CAAC,CAC7B,CAEA;AACA;AACA;AACA,QAASQ,YAAW,CAACd,SAAS,CAAEC,OAAO,CAAEM,WAAW,CAAE,CAClD,GAAIW,KAAI,CAAG,CAACjB,OAAO,CAAC,CACpB,GAAIS,YAAW,CAAGT,OAAO,CAEzB,MAAOS,WAAW,GAAKV,SAAS,CAAE,CAC9BU,WAAW,CAAGH,WAAW,CAACY,GAAG,CAACT,WAAW,CAAC,CAC1CQ,IAAI,CAACE,OAAO,CAACV,WAAW,CAAC,CAC7B,CAEA,MAAOQ,KAAI,CACf,CAEA,QAASG,aAAY,CAACC,IAAI,CAAEnB,SAAS,CAAEC,SAAS,CAAE,CAC9C,GAAMmB,UAAS,CAAG,EAAE,CAEpB,GAAMC,MAAK,CAAGF,IAAI,CAAGnB,SAAS,CAC9B,GAAMsB,MAAK,CAAGH,IAAI,CAAGnB,SAAS,CAC9B,GAAMuB,KAAI,CAAGJ,IAAI,CAAG,CAAC,CACrB,GAAMK,KAAI,CAAGL,IAAI,CAAG,CAAC,CACrB,GAAMM,IAAG,CAAGzB,SAAS,CAAGC,SAAS,CACjC,GAAMyB,OAAM,CAAGC,IAAI,CAACC,KAAK,CAACT,IAAI,CAACnB,SAAS,CAAC,CAEzC;AACA,GAAIqB,KAAK,EAAI,CAAC,CAAE,CACZD,SAAS,CAACV,IAAI,CAACW,KAAK,CAAC,CACzB,CACA;AACA,GAAIE,IAAI,CAAIG,MAAM,CAAG1B,SAAU,GAAKA,SAAS,CAAE,CAC3CoB,SAAS,CAACV,IAAI,CAACa,IAAI,CAAC,CACxB,CACA;AACA,GAAID,KAAK,CAAGG,GAAG,CAAE,CACbL,SAAS,CAACV,IAAI,CAACY,KAAK,CAAC,CACzB,CACA;AACA,GAAIH,IAAI,CAAIO,MAAM,CAAG1B,SAAU,GAAK,CAAC,CAAE,CACnCoB,SAAS,CAACV,IAAI,CAACc,IAAI,CAAC,CACxB,CACA,MAAOJ,UAAS,CACpB,CAEA,QAASR,sBAAqB,CAACO,IAAI,CAAErB,OAAO,CAAEK,YAAY,CAAEJ,SAAS,CAAEC,SAAS,CAAEC,SAAS,CAAE,CACzF,GAAMmB,UAAS,CAAGF,YAAY,CAACC,IAAI,CAAEnB,SAAS,CAAEC,SAAS,CAAC,CAC1D,MAAOmB,UAAS,CAACS,MAAM,CAAC,SAAAhB,QAAQ,QAAI,CAACV,YAAY,CAACM,QAAQ,CAACI,QAAQ,CAAC,GAChC,CAACd,SAAS,CAACU,QAAQ,CAACI,QAAQ,CAAC,EAAIA,QAAQ,GAAKf,OAAO,CAAC,GAAC,CAC/F"},"metadata":{},"sourceType":"module","externalDependencies":[]}